| Предмет                               | Зачем изучать?                                              | Лучшая книга                                              | Лучшие видео                      |
| -------------------------------------- | -----------------------------------------------------------| ----------------------------------------------------------| --------------------------------- |
| **[Программирование](#программирование)**               | Чтобы не быть тем человеком, который "не совсем понимает" что-то уровня рекурсии. | *Структура и интерпретация компьютерных программ*     | Brian Harvey’s Berkeley CS 61A    |
| **[Архитектура компьютера](#архитектура-компьютера)**          | Когда ты не знаешь, как устроен компьютер, твое понимание того, что можно и нельзя делать с кодом, будет поверхностным.          | *Архитектура компьютера и проектирование компьютерных систем*                      | Berkeley CS 61C                   |
| **[Алгоритмы и структуры данных](#алгоритмы-и-структуры-данных)** | Если ты не знаешь, как использовать базовые структуры данных, такие как стек, очередь, дерево, графы, ты не сможешь решать сложные задачи.  | *Алгоритмы. Руководство по разработке*                           | Steven Skiena’s lectures          |
| **[Математика для CS](#математика-для-cs)**                    | CS, по сути, одно из ответвлений прикладной математики. Поэтому, зание математики даст тебе значительное преимущество. | *Mathematics for Computer Science*                      | Tom Leighton’s MIT 6.042J         |
| **[Операционные системы](#операционные-системы)**              | Большинство кода, который ты пишешь, выполняется ОС. Поэтому, ты должен знать, как ОС и код взаимодействуют. | *Operating Systems: Three Easy Pieces*                  | Berkeley CS 162                   |
| **[Компьютерные сети](#компьютерные-сети)**            | Интернет везде: узнай как он работает, чтобы использовать его потенциал на 100%. | *Computer Networking: A Top-Down Approach*              | Stanford CS 144                   |
| **[Базы данных](#базы-данных)**                      | Данные - это основа большинства программ, но лишь избранные понимают, как системы баз данных работают на самом деле.  | *Readings in Database Systems*                          | Joe Hellerstein’s Berkeley CS 186 |
| **[Языки и компиляторы](#языки-и-компиляторы)**        | Если ты понимаешь, как работают языки и компиляторы, ты сможешь писать более качественный код и изучать новые языки эффективнее. | *Компиляторы: принципы, технологии и инструменты*           | Alex Aiken’s course on Lagunita   |
| **[Распределенные системы](#распределенные-системы)**        | В наши дни *большинство* систем - распределенные системы. | *Распределенные системы. Принципы и парадигмы* | MIT 6.824 |



### Программирование


**ПРАВИЛА ОФОРМЛЕНИЯ ФАЙЛА README.MD НА GITHUB*
<GITHUB></GITHUB>
Если вы начали работу на GitHub, решили загрузить туда свой проект для совместной работы с единомышленниками, то, скорее всего, в первую очередь перед вами встанет проблема создания первого файла – файла «readme.md».

Можно, конечно, просто выложить простой, неформатированный текстовой файл. Но вам захочется сделать его удобочитаемым, чтобы ссылки были выделены, блоки кода, присутствовали таблицы и так далее…
Эта статья поможет вам в этом.

Для форматирования текста на GitHub используются достаточно простые правила. Я перечислю основные и достаточные, так как не претендую на полноту официального руководства.

Текст можно обработать в любом простом текстовом редакторе, например в Notepad++, которым пользуюсь сам. А можно и прямо на GitHub редактировать файл в он-лайн режиме.

Стилистическая разметка должна быть такой:

Разбиение на абзацы производится вставкой пустой строки между ними (нажмите "Enter" после абзаца).

Горизонтальная полоса между абзацами - тег <hr> - три или более звёздочек или дефисов

Первый абзац
***
Второй абзац
или

Первый абзац
---
Второй абзац
Далее - заголовки и прочее:

h1 заголовок первого уровня
=====================
h2 заголовок второго уровня
-----------------------------------
### h3 заголовок третьего уровня
#### h4 заголовок четвёртого уровня
##### h5 заголовок пятого уровня
###### h6 заголовок шестого уровня
Оформление ссылки [Видимая часть, название ссылки] (http://webdesign.ru.net адрес ссылки - невидимая часть)

[Мой сайт](http://webdesign.ru.net)
Если заключить адрес в угловые скобки, то он автоматически станет ссылкой

<http://webdesign.ru.net>
Выделение жирным шрифтом

**Жирный шрифт**
***Наклонный жирный***
Выделение тёмным фоном прямо в тексте

`выделенные слова`
Блок текста с более тёмным фоном, четыре пробела (и более) от начала каждой строки

    dir /fonts
    dir /images
    dir /js
Блоки текста с подвеченным синтаксисом. Выделенный цветом фона блок с html-кодом. Теги выделяются цветом по правилам html

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```
Выделенный цветом фона блок с php-кодом. Теги выделяются цветом по правилам php

```php
<?php here_pagecontent(); ?>
```
Выделенный цветом фона блок с каскадными таблицами. Теги выделяются цветом по правилам css

```scss /* или css */
@import "bower_components/tree-normalize/generic.normalize";
h1 {
 font-size:1.5em;
 font-weight: 300;
}
```
И так далее...

Блок текста, выделенный тёмной полосой по левому краю (цитата)

> Текст
> 
> Продолжение текста выделенного блока
> Завершение текста
Допустимы вложенные цитаты (цитата в цитате). Тогда цитата второго уровня выделяется двумя знаками ">>", а цитата третьего уровня вложенности - тремя.

Таблица с чередованием светлых и тёмных строк (зебра)

Название файла  | Содержание файла
----------------|----------------------
style.css       | Пустой файл каскадной таблицы стилей, в который производится сбока необходимых стилей
reset.css       | Reset CSS от Эрика Мейера
normalize.css   | Нормалайзер CSS от Nicolas Gallagher
block.css       | Основные стили блоков системы
addition.css    | Дополнительные стили
fontawesome.css | Стили иконочного шрифта
layout.css      | Основные стили, применительно к определённому сайту
lightbox.css    | Стили лайтбокса, если таковой используется
index.html      | Индексный файл для проверки вносимых изменений
<li> Листинг - ненумерованый список

* Пункт 1
* Пункт 2
* Пункт 3
Нумерованный список создаётся ещё проще:

1. Пункт 1
2. Пункт 2
3. Пункт 3
italic - наклонный шрифт. Пробел, знак препинания или подчёркивание отменяют правило маркера

_наклонный_ _шрифт_ _наклонный__шрифт_
Комбинируя эти маркеры вы сможете правильно разметить свой текст, сделать его более понятным.

Надеюсь, что эта статья будет вам полезна. Успехов в работе на GitHub!

UPDATE!

Вставка изображения в текст

![screenshot of sample](http://webdesign.ru.net/images/Heydon_min.jpg)
Восклицательный знак обозначает изображение, в квадратных скобках даётся краткое описание, в обычных круглых скобках - полная ссылка на изображение.

    
    
    
    
Основи програмування:

Введення в програмування
Синтаксис і структура коду
Типи даних і змінні
Умовні оператори
Цикли
Функції
Масиви
Рядки
Вказівники
Структури
Об'єктно-орієнтоване програмування:

Введення в ООП
Класи і об'єкти
Наслідування
Поліморфізм
Абстракція
Інтерфейси
Шаблони проектування
Алгоритми та Структури даних:

Введення в алгоритми та структури даних
Масиви та списки
Дерева
Графи
Хеш-таблиці
Сортування і пошук
Аналіз алгоритмів
Многопоточність та Паралелізм:

Введення в многопоточність
Потоки виконання
Синхронізація
Конкурентний доступ до даних
Проблеми многопоточності
Паралельні алгоритми та структури даних
Мережеве програмування:

Введення в мережеве програмування
Основи TCP/IP протоколу
Сокети
Мережеві сервери та клієнти
Протоколи передачі даних
Безпека мережевого програмування
Графічне програмування:

Введення в графічне програмування
Основи візуалізації даних
Графічний інтерфейс користувача
Робота з графікою і мультимедіа
Графічні бібліотеки
Розробка веб-додатків:

Введення в розробку веб-додатків
HTML та CSS
JavaScript та AJAX
Серверні технології
Бази даних для веб-додатків
Фреймворки для веб-додатків    
   
    
    
### Тема 0 | Точка Входу


    
    
### Тема 1.1 | Змінні та типи даних
Усі типи даних мови C++ можна розділити на основні (базові) і складені. Основні типи визначені для представлення цілих, дійсних, символьних і логічних даних. На основі цих типів вводиться опис складених типів, до яких належать масиви, перелічення, функції, структури, посилання, покажчики, об’єднання і класи.

* int (цілий); 
* char (символьний); 
* bool (логічний); 
* float (дійсний);
* double (дійсний з подвійною точністю); 
* void (порожній, не має значення).

> Типи int, char, bool називають цілими, а типи float та double — дійсними з плаваючою крапкою. Код, що формує компілятор для обробки цілих величин, відрізняється від коду для величин з плаваючою крапкою.
 
Для уточнення внутрішнього подання та діапазону значень стандартних типів мова C++ використовує чотири специфікатори типу: 
* short (короткий);
* long (довгий); 
* signed (знаковий); 
* unsigned (беззнаковий).

| Тип                               | Розмір Байт                                             | Значення                                         |
| -------------------------------------- | -----------------------------------------------------------| ----------------------------------------------------------|
| bool | 1 | true або false (0 / 1) |
| unsigned short int | 2 | від 0 до 65535 |
| short int | 2 | від -32768 до 32767 |
| unsigned long int | 4 | від 0 до 4 294 967 295 |
| long int | 4 | від -2 147 483 648 до 2 147 483 647 |
| int(16) | 2 | від -32 768 до 32 767 |
| int(32) | 4 | від -2 147 483 648 до 2 147 483 647 |
| unsigned int (16) | 2 | від 0 до 65535 |
| unsigned int (32) | 4 | від 0 до 4 294 967 295 |
| char | 1 | від 0 до 256 |
| float | 4 | від 1.2е-38 до 3.4е38 |
| double | 8 | від 2.2е-308 до 1.8е308 |
| long double | 10 | від 3.4е-4932 до 3.4е+4932 |

    
### Тема 1.2 | Оператори та вирази
Оператори бувають трьох типів:
* **Унарні**, які працюють з одним операндом. Наприклад, оператор − (мінус). У виразі −7, оператор − застосовується тільки до одного операнду (7) для генерації нового значення (−7).
* **Бінарні**, які працюють з двома операндами (лівим і правим). Наприклад, оператор +. У виразі 5 + 2, оператор + працює з лівим операндом (5) і правим (2) для генерації нового значення (7).
* **Тернарні**, які працюють з трьома операндами. У мові C++ є тільки один тернарний оператор.

> Зверніть увагу, деякі оператори можуть мати кілька значень. Наприклад, оператор − (мінус) може використовуватися в двох контекстах: як унарний оператор для зміни знаку числа (наприклад, конвертувати 7 в −7 і навпаки), і як бінарний для виконання арифметичної операції віднімання (наприклад, 4 − 3).


### Арифметичні оператори:
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| + | додає два операнди разом |
| - | віднімає один операнд від іншого |
| * | множить два операнди |
| / | ділить один операнд на інший |
| % | повертає остачу від ділення одного операнду на інший | 
```c++
int a = 5;
int b = 3;

// Оператор "+"
int sum = a + b;  // Додаємо значення змінних "a" і "b" і зберігаємо результат в змінній "sum"

// Оператор "-"
int difference = a - b;  // Віднімаємо значення змінної "b" від "a" і зберігаємо результат в змінній "difference"

// Оператор "*"
int product = a * b;  // Множимо значення змінних "a" і "b" і зберігаємо результат в змінній "product"

// Оператор "/"
double division = static_cast<double>(a) / b;  // Ділимо значення змінної "a" на значення змінної "b" і зберігаємо результат в змінній "division"

// Оператор "%"
int remainder = a % b;  // Знаходимо остачу від ділення значення змінної "a" на значення змінної "b" і зберігаємо результат в змінній "remainder"
```
    
    
 ### Оператори присвоєння:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| = | присвоює значення правого операнду лівому операнду |
| += | додає значення правого операнду до лівого операнду і присвоює результат лівому операнду |
| -= | віднімає значення правого операнду від лівого операнду і присвоює результат лівому операнду |
| *= | множить значення лівого операнду на значення правого операнду і присвоює результат лівому операнду |
| /= | ділить значення лівого операнду на значення правого операнду і присвоює результат лівому операнду | 
```c++
int a = 5;
int b = 3;

// Оператор "="
int result1 = a;  // Присвоюємо значення змінної "a" змінній "result1"

// Оператор "+="
result1 += b;  // Додаємо значення змінної "b" до "result1" і присвоюємо результат змінній "result1"

// Оператор "-="
result1 -= b;  // Віднімаємо значення змінної "b" від "result1" і присвоюємо результат змінній "result1"

// Оператор "*="
result1 *= b;  // Множимо значення змінної "result1" на значення змінної "b" і присвоюємо результат змінній "result1"

// Оператор "/="
result1 /= b;  // Ділимо значення змінної "result1" на значення змінної "b" і присвоюємо результат змінній "result1"
```
    
### Оператори порівняння:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| == | пперевіряє, чи рівні два операнди |
| != | перевіряє, чи не рівні два операнди |
| < | перевіряє, чи перший операнд менше другого |
| > | перевіряє, чи перший операнд більше другого |
| <= | перевіряє, чи перший операнд менше або рівний другому |
| >= | перевіряє, чи перший операнд більше або рівний другому |
```c++
int a = 5;
int b = 3;

// Оператор "=="
bool result1 = (a == b);  // Результат: false, оскільки a не дорівнює b

// Оператор "!="
bool result2 = (a != b);  // Результат: true, оскільки a не дорівнює b

// Оператор "<"
bool result3 = (a < b);  // Результат: false, оскільки a не менше b

 // Оператор ">"
bool result4 = (a > b);  // Результат: true, оскільки a більше b

// Оператор "<="
bool result5 = (a <= b);  // Результат: false, оскільки a не менше або рівне b
   
// Оператор ">="
bool result6 = (a >= b);  // Результат: true, оскільки a більше або рівне b
```  
    
### Логічні оператори:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| && | повертає "true", якщо обидва операнди є "true" |
| \|\| | повертає "true", якщо принаймні один операнд є "true" |
| ! | повертає "true", якщо операнд є "false", і навпаки |
```c++
bool a = true;
bool b = false;

// Логічний оператор "&&" (AND)
bool result1 = a && b;  // Результат: false, оскільки обидва операнди не є true
bool result2 = a && !b; // Результат: true, оскільки a = true і !b = true

// Логічний оператор "||" (OR)
bool result3 = a || b;  // Результат: true, оскільки принаймні один операнд (a) є true
bool result4 = !a || b; // Результат: false, оскільки !a = false і b = false

// Логічний оператор "!" (NOT)
bool result5 = !a; // Результат: false, оскільки a = true, а оператор "!" дає зворотне значення

// Використання логічних операторів в умовних виразах (if-else)
if (a && b) {
    // Цей блок коду не виконається, оскільки обидва операнди не є true
    // ...
}
else if (a || b) {
    // Цей блок коду виконається, оскільки принаймні один операнд (a) є true
    // ...
}
else {
    // Цей блок коду не виконається, оскільки всі умови не виконуються
    // ...
}
```   
    
### Побітові оператори:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| \| | побітове І (AND) двох операндів |
| != | побітове АБО (OR) двох операндів |
| ^ | побітове виключне АБО (XOR) двох операндів |
| << | зсув вліво бітів першого операнду на кількість позицій, вказаних другим операндом |
| >> | зсув вправо бітів першого операнду на кількість позицій, вказаних другим операндом |
| ~ | побітовий зворот (NOT) операнду |
```c++
// Побітовий оператор "&" (AND)
int a = 5;  // 0000 0101 в двійковій системі
int b = 3;  // 0000 0011 в двійковій системі
int result1 = a & b;  // Результат: 0000 0001 в двійковій системі (1 в десятковій системі)

// Побітовий оператор "|" (OR)
int result2 = a | b;  // Результат: 0000 0111 в двійковій системі (7 в десятковій системі)

// Побітовий оператор "^" (XOR)
int result3 = a ^ b;  // Результат: 0000 0110 в двійковій системі (6 в десятковій системі)

// Побітовий оператор "<<" (зсув вліво)
int c = 8;  // 0000 1000 в двійковій системі
int result4 = c << 2;  // Результат: 0010 0000 в двійковій системі (32 в десятковій системі)

// Побітовий оператор ">>" (зсув вправо)
int d = 16;  // 0001 0000 в двійковій системі
int result5 = d >> 3;  // Результат: 0000 0010 в двійковій системі (2 в десятковій системі)

// Побітовий оператор "~" (NOT)
int e = 10;  // 0000 1010 в двійковій системі
int result6 = ~e;  // Результат: 1111 0101 в двійковій системі (-11 в десятковій системі)
```  
    
### Оператори інкремента/декремента:
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| -- |  декремента значення операнду на 1 |
| ++ |  інкрементує значення операнду на 1 |
```c++
int a = 5;
a++; // Результат: a = 6
a--; // Результат: a = 5  
```   
    
    
### Тернарний оператор
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| ?: | дозволяє зробити умовний вибір |
```c++
int a = 5;
bool b = (a > 10) ? true : false; // Результат: b = false;
```    
    
### Тема 1.3 | Умовні конструкції (if-else, switch)
Для здійснення розгалуження в програмі використовуються так звані умовні оператори
* Оператор if Оператор if робить розгалуження програми залежно від результату перевірки деякої умови на істинність: 
    if (умова) оператор1;
Оператор if Оператор if робить рПараметр умова може бути будь-яким виразом, але найчастіше вираз містить оператори порівняння. Якщо умова, що перевіряється, має істинне значення (true), виконується оператор1. А якщо ні (false), виконання програми переходить до оператора, що йде за умовним оператором.згалуження програми залежно від результату перевірки деякої умови на істинність: 
```c++
if (умова) оператор1;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови

```
    
* Оператор if-else Синтаксис оператора if із ключовим словом else має такий вигляд: 
```c++
if (умова) оператор1; else оператор2;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}
else{
    cout << "False"; // Тіло яке спрацює при НЕ виконані умови
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови
else
    cout << "False"; // Спрацює при НЕ виконані умови
```
    
* Оператор if-else if Синтаксис оператора if із ключовим словом else if має такий вигляд: 
```c++
if (умова) оператор1; else if (умова2) оператор2;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}
else if(b == 0){
    cout << "False"; // Тіло яке спрацює при виконані умови2
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови
else if(b == 0)
    cout << "False"; // Спрацює при виконані умови2
```

* Замість операторів if-else можна використовувати умовний оператор "? :". Така конструкція має наступний синтаксис: 
```c++
умова ? вираз1 : вираз2;
```
```c++
int a = 10, b = 20, max;
max = (a > b) ? a : b; // Результат: max = 20 ( true : false )
}
```    

* Оператор switch Ще однієї альтернативою керуючої конструкції if-else може служити оператор розгалуження switch.
Синтаксис оператора switch:
```c++
switch(вираз)
{
    case Константа1 : група операторів; break ;
    case Константа2 : група операторів;  break ;
    default Константа3 : група операторів; 
}
```
```c++
switch (вираз) {
    case значення1:
        // Блок коду, який виконується, якщо вираз має значення1
        // Після виконання цього блоку, виконається нижній блок через відсутність break;
    case значення2:
        // Блок коду, який виконується, якщо вираз має значення2
        break;
    ...
    default:
        // Блок коду, який виконується, якщо вираз не має жодного зазначеного значення
        break;
}
```  
    
### Тема 1.4 | Цикли (for, while, do-while)
У мові програмування C++ є три основних типи циклів: цикл "for", цикл "while" і цикл "do-while". Кожен з них дозволяє виконувати блок коду повторно залежно від заданої умови. Опишу кожен з них детально:

* Цикл "for":
Цикл "for" складається з трьох частин: ініціалізація, умова і ітерація. Умова перевіряється перед кожною ітерацією. Якщо умова є істинною, виконується блок коду, після чого відбувається ітерація. Процес повторюється до тих пір, поки умова стає хибною. Ініціалізація виконується лише один раз на початку циклу.
    
```c++
for (ініціалізація; умова; ітерація) {
    // Блок коду, який виконується у кожній ітерації циклу
}
```
```c++
for (int i = 0; i <= 5; i++) {
    cout << i << " ";    // Результат: 0 1 2 3 4 5
}
```  

* Цикл "while":
Цикл "while" перевіряє умову перед кожною ітерацією. Якщо умова є істинною, виконується блок коду. Цикл продовжується, доки умова залишається істинною.

```c++
while (умова) {
    // Блок коду, який виконується, поки умова є істинною
}
```
                 
```c++
int i = 0;

while (i <= 5) {
    cout << i << " ";
    i++;    // Результат: 0 1 2 3 4 5
}
```  

* Цикл "do-while":
Цикл "do-while" спочатку виконує блок коду, а потім перевіряє умову. Якщо умова є істинною, цикл повторюється. Відмінністю цього циклу від "while" є те, що блок коду виконується принаймні один раз, навіть якщо умова вже хибна.
    
```с++
do {
    // Блок коду, який виконується, поки умова є істинною
} while (умова);
```
                 
```c++
int i = 0;

do {
    cout << i << " ";
    i++;
} while (i <= 5);  // Результат: 0 1 2 3 4 5
```  
    
### Тема 1.4 | Функції та повернення значень
У мові програмування C++ функції є основними засобами організації програм та виконання повторюваних завдань. Функції дозволяють групувати певні дії або операції разом та використовувати їх у різних частинах програми. Опишу структуру функції та повернення значень в C++:   
```c++
тип_повернення назва_функції(параметри) {
    // (Тіло) Блок коду, який виконується при виклику функції
    // Операції та дії, які мають бути виконані
    return значення; // Опціональне повернення значення
}
```           
* тип_повернення - це тип даних, який функція повертає після свого виконання. Якщо функція не повертає значення, то використовується тип void. 
* назва_функції - це унікальне ім'я, яке ідентифікує функцію. 
* параметри - це значення, які можуть бути передані у функцію для виконання певних операцій. Параметри є необов'язковими і можуть бути відсутніми. 
* return значення - це опціональна команда для повернення значення з функції. Вона виконується, якщо функція повертає значення.        
                
Функції в C++ можуть повертати значення за допомогою оператора return. Значення, що повертається, повинно бути того ж типу, що й зазначений у типі повернення функції. Якщо функція виконується без повернення значення (тип повернення - void), оператор return може бути пропущений або використаний без значення.
```c++
int Add(int a, int b) {
    int sum = a + b;
    return sum;  // Результат: це сума a і b
}
```         
Приклад використання нашої функції:
```c++
int result = Add(5, 5) // Результат: result = 10
```                
                
Inline-функції - це функції, які можуть бути вбудовані безпосередньо в місце їх виклику. Коли функція оголошується як inline, компілятор може вирішити скопіювати тіло функції в місце виклику, замість фактичного виклику функції. Це може привести до покращення швидкодії програми шляхом уникнення накладних витрат на виклик функції.    
```c++          
inline тип_повернення назва_функції(параметри) {
    // Тіло функції
}        
```    
                
 <details>

<summary>Ремарка як це виглядає зі строни виконання</summary>
Якщо описати нашу функцію так:

```c++
inline int Add(int a, int b)
{
    int result = a + b;
    return result;
}
```
то замість
```c++
cout << Add(2, 2);
```
ми отримаємо розворот функції в набір операторів:

```c++
int result = a + b;
cout << result;
```

</details>

Рекурсія - це процес, коли функція викликає саму себе. Рекурсивні функції розбивають велику задачу на менші частини того ж типу. Кожне викликання функції робить свій внесок у вирішення задачі, а рекурсивні виклики продовжуються досягнення базового випадку, коли рекурсія припиняється. Приклад рекурсивної функції для обчислення факторіала:
```c++
int факторіал(int n) {
    if (n == 0) {
        return 1; // Базовий випадок: факторіал 0 = 1
    } else {
        return n * факторіал(n - 1); // Рекурсивний виклик
    }
}
```
У цьому прикладі функція факторіал використовує рекурсію для обчислення факторіала числа n. Кожен рекурсивний виклик зменшує значення n на 1, аж досягне базового випадку, коли n стає рівним 0. Рекурсія вимагає добре визначеного базового випадку, щоб уникнути безкінечного виконання.

### Тема 2.1 |Огляд синтаксису C++
<details>

<summary> Точка входу в програму: </summary>
Функція main є точкою входу в програму. Вона має повернути ціле значення (зазвичай 0) і може приймати аргументи командного рядка.
```c++
int main() {
    // Тіло функції main
    return 0;
}
```
</details>

<details>

<summary> Оголошення змінних: </summary>
тип_даної назва_змінної;
```c++
int value;
```
</details>
    
<details>

<summary> Оголошення змінних: </summary>
тип_даної назва_змінної;
```c++
int value;
```
</details>
    
    
    
```c++
int main(){
std::cout << "Hello World" << endl;
}
```    

Commpile Error | Помилка яка відбувається під час компіляції, починається через C  
Linked Error | Помилка яка відбувається під час звязку/підвязки , починається через LNK, може бути відсутня під час компіляції    
    
 
    
    
    
 
    
    
    
