
### Матеріали | Сайти йдуть у послідовності
https://informatics.msk.ru/
https://acmp.ru/index.asp?main=tasks
https://acm.timus.ru/
https://leetcode.com/
https://www.hackerrank.com/
https://codeforces.com/
https://www.codechef.com/
https://usaco.guide/


### Тема 0 | Точка Входу  
    
### Тема 1.1 | Змінні та типи даних
Усі типи даних мови C++ можна розділити на основні (базові) і складені. Основні типи визначені для представлення цілих, дійсних, символьних і логічних даних. На основі цих типів вводиться опис складених типів, до яких належать масиви, перелічення, функції, структури, посилання, покажчики, об’єднання і класи.

* int (цілий); 
* char (символьний); 
* bool (логічний); 
* float (дійсний);
* double (дійсний з подвійною точністю); 
* void (порожній, не має значення).

> Типи int, char, bool називають цілими, а типи float та double — дійсними з плаваючою крапкою. Код, що формує компілятор для обробки цілих величин, відрізняється від коду для величин з плаваючою крапкою.
 
Для уточнення внутрішнього подання та діапазону значень стандартних типів мова C++ використовує чотири специфікатори типу: 
* short (короткий);
* long (довгий); 
* signed (знаковий); 
* unsigned (беззнаковий).

| Тип                               | Розмір Байт                                             | Значення                                         |
| -------------------------------------- | -----------------------------------------------------------| ----------------------------------------------------------|
| bool | 1 | true або false (0 / 1) |
| unsigned short int | 2 | від 0 до 65535 |
| short int | 2 | від -32768 до 32767 |
| unsigned long int | 4 | від 0 до 4 294 967 295 |
| long int | 4 | від -2 147 483 648 до 2 147 483 647 |
| int(16) | 2 | від -32 768 до 32 767 |
| int(32) | 4 | від -2 147 483 648 до 2 147 483 647 |
| unsigned int (16) | 2 | від 0 до 65535 |
| unsigned int (32) | 4 | від 0 до 4 294 967 295 |
| char | 1 | від 0 до 256 |
| float | 4 | від 1.2е-38 до 3.4е38 |
| double | 8 | від 2.2е-308 до 1.8е308 |
| long double | 10 | від 3.4е-4932 до 3.4е+4932 |

    
### Тема 1.2 | Оператори та вирази
Оператори бувають трьох типів:
* **Унарні**, які працюють з одним операндом. Наприклад, оператор − (мінус). У виразі −7, оператор − застосовується тільки до одного операнду (7) для генерації нового значення (−7).
* **Бінарні**, які працюють з двома операндами (лівим і правим). Наприклад, оператор +. У виразі 5 + 2, оператор + працює з лівим операндом (5) і правим (2) для генерації нового значення (7).
* **Тернарні**, які працюють з трьома операндами. У мові C++ є тільки один тернарний оператор.

> Зверніть увагу, деякі оператори можуть мати кілька значень. Наприклад, оператор − (мінус) може використовуватися в двох контекстах: як унарний оператор для зміни знаку числа (наприклад, конвертувати 7 в −7 і навпаки), і як бінарний для виконання арифметичної операції віднімання (наприклад, 4 − 3).


### Арифметичні оператори:
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| + | додає два операнди разом |
| - | віднімає один операнд від іншого |
| * | множить два операнди |
| / | ділить один операнд на інший |
| % | повертає остачу від ділення одного операнду на інший | 
```c++
int a = 5;
int b = 3;

// Оператор "+"
int sum = a + b;  // Додаємо значення змінних "a" і "b" і зберігаємо результат в змінній "sum"

// Оператор "-"
int difference = a - b;  // Віднімаємо значення змінної "b" від "a" і зберігаємо результат в змінній "difference"

// Оператор "*"
int product = a * b;  // Множимо значення змінних "a" і "b" і зберігаємо результат в змінній "product"

// Оператор "/"
double division = static_cast<double>(a) / b;  // Ділимо значення змінної "a" на значення змінної "b" і зберігаємо результат в змінній "division"

// Оператор "%"
int remainder = a % b;  // Знаходимо остачу від ділення значення змінної "a" на значення змінної "b" і зберігаємо результат в змінній "remainder"
```
    
    
 ### Оператори присвоєння:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| = | присвоює значення правого операнду лівому операнду |
| += | додає значення правого операнду до лівого операнду і присвоює результат лівому операнду |
| -= | віднімає значення правого операнду від лівого операнду і присвоює результат лівому операнду |
| *= | множить значення лівого операнду на значення правого операнду і присвоює результат лівому операнду |
| /= | ділить значення лівого операнду на значення правого операнду і присвоює результат лівому операнду | 
```c++
int a = 5;
int b = 3;

// Оператор "="
int result1 = a;  // Присвоюємо значення змінної "a" змінній "result1"

// Оператор "+="
result1 += b;  // Додаємо значення змінної "b" до "result1" і присвоюємо результат змінній "result1"

// Оператор "-="
result1 -= b;  // Віднімаємо значення змінної "b" від "result1" і присвоюємо результат змінній "result1"

// Оператор "*="
result1 *= b;  // Множимо значення змінної "result1" на значення змінної "b" і присвоюємо результат змінній "result1"

// Оператор "/="
result1 /= b;  // Ділимо значення змінної "result1" на значення змінної "b" і присвоюємо результат змінній "result1"
```
    
### Оператори порівняння:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| == | пперевіряє, чи рівні два операнди |
| != | перевіряє, чи не рівні два операнди |
| < | перевіряє, чи перший операнд менше другого |
| > | перевіряє, чи перший операнд більше другого |
| <= | перевіряє, чи перший операнд менше або рівний другому |
| >= | перевіряє, чи перший операнд більше або рівний другому |
```c++
int a = 5;
int b = 3;

// Оператор "=="
bool result1 = (a == b);  // Результат: false, оскільки a не дорівнює b

// Оператор "!="
bool result2 = (a != b);  // Результат: true, оскільки a не дорівнює b

// Оператор "<"
bool result3 = (a < b);  // Результат: false, оскільки a не менше b

 // Оператор ">"
bool result4 = (a > b);  // Результат: true, оскільки a більше b

// Оператор "<="
bool result5 = (a <= b);  // Результат: false, оскільки a не менше або рівне b
   
// Оператор ">="
bool result6 = (a >= b);  // Результат: true, оскільки a більше або рівне b
```  
    
### Логічні оператори:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| && | повертає "true", якщо обидва операнди є "true" |
| \|\| | повертає "true", якщо принаймні один операнд є "true" |
| ! | повертає "true", якщо операнд є "false", і навпаки |
```c++
bool a = true;
bool b = false;

// Логічний оператор "&&" (AND)
bool result1 = a && b;  // Результат: false, оскільки обидва операнди не є true
bool result2 = a && !b; // Результат: true, оскільки a = true і !b = true

// Логічний оператор "||" (OR)
bool result3 = a || b;  // Результат: true, оскільки принаймні один операнд (a) є true
bool result4 = !a || b; // Результат: false, оскільки !a = false і b = false

// Логічний оператор "!" (NOT)
bool result5 = !a; // Результат: false, оскільки a = true, а оператор "!" дає зворотне значення

// Використання логічних операторів в умовних виразах (if-else)
if (a && b) {
    // Цей блок коду не виконається, оскільки обидва операнди не є true
    // ...
}
else if (a || b) {
    // Цей блок коду виконається, оскільки принаймні один операнд (a) є true
    // ...
}
else {
    // Цей блок коду не виконається, оскільки всі умови не виконуються
    // ...
}
```   
    
### Побітові оператори:   
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| \| | побітове І (AND) двох операндів |
| != | побітове АБО (OR) двох операндів |
| ^ | побітове виключне АБО (XOR) двох операндів |
| << | зсув вліво бітів першого операнду на кількість позицій, вказаних другим операндом |
| >> | зсув вправо бітів першого операнду на кількість позицій, вказаних другим операндом |
| ~ | побітовий зворот (NOT) операнду |
```c++
// Побітовий оператор "&" (AND)
int a = 5;  // 0000 0101 в двійковій системі
int b = 3;  // 0000 0011 в двійковій системі
int result1 = a & b;  // Результат: 0000 0001 в двійковій системі (1 в десятковій системі)

// Побітовий оператор "|" (OR)
int result2 = a | b;  // Результат: 0000 0111 в двійковій системі (7 в десятковій системі)

// Побітовий оператор "^" (XOR)
int result3 = a ^ b;  // Результат: 0000 0110 в двійковій системі (6 в десятковій системі)

// Побітовий оператор "<<" (зсув вліво)
int c = 8;  // 0000 1000 в двійковій системі
int result4 = c << 2;  // Результат: 0010 0000 в двійковій системі (32 в десятковій системі)

// Побітовий оператор ">>" (зсув вправо)
int d = 16;  // 0001 0000 в двійковій системі
int result5 = d >> 3;  // Результат: 0000 0010 в двійковій системі (2 в десятковій системі)

// Побітовий оператор "~" (NOT)
int e = 10;  // 0000 1010 в двійковій системі
int result6 = ~e;  // Результат: 1111 0101 в двійковій системі (-11 в десятковій системі)
```  
    
### Оператори інкремента/декремента:
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| -- |  декремента значення операнду на 1 |
| ++ |  інкрементує значення операнду на 1 |
```c++
int a = 5;
a++; // Результат: a = 6
a--; // Результат: a = 5  
```   
    
    
### Тернарний оператор
| Тип                               | Значення                                         |
| -------------------------------------- | ----------------------------------------------------------|
| ?: | дозволяє зробити умовний вибір |
```c++
int a = 5;
bool b = (a > 10) ? true : false; // Результат: b = false;
```    
    
### Тема 1.3 | Умовні конструкції (if-else, switch)
Для здійснення розгалуження в програмі використовуються так звані умовні оператори
* Оператор if Оператор if робить розгалуження програми залежно від результату перевірки деякої умови на істинність: 
    if (умова) оператор1;
Оператор if Оператор if робить рПараметр умова може бути будь-яким виразом, але найчастіше вираз містить оператори порівняння. Якщо умова, що перевіряється, має істинне значення (true), виконується оператор1. А якщо ні (false), виконання програми переходить до оператора, що йде за умовним оператором.згалуження програми залежно від результату перевірки деякої умови на істинність: 
```c++
if (умова) оператор1;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови

```
    
* Оператор if-else Синтаксис оператора if із ключовим словом else має такий вигляд: 
```c++
if (умова) оператор1; else оператор2;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}
else{
    cout << "False"; // Тіло яке спрацює при НЕ виконані умови
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови
else
    cout << "False"; // Спрацює при НЕ виконані умови
```
    
* Оператор if-else if Синтаксис оператора if із ключовим словом else if має такий вигляд: 
```c++
if (умова) оператор1; else if (умова2) оператор2;
```
```c++ 
// Спосіб 1
if (b > 0){
    cout << "True"; // Тіло яке спрацює при виконані умови
}
else if(b == 0){
    cout << "False"; // Тіло яке спрацює при виконані умови2
}

// Спосіб 2
if (b > 0) 
    cout << "True"; // Спрацює при виконані умови
else if(b == 0)
    cout << "False"; // Спрацює при виконані умови2
```

* Замість операторів if-else можна використовувати умовний оператор "? :". Така конструкція має наступний синтаксис: 
```c++
умова ? вираз1 : вираз2;
```
```c++
int a = 10, b = 20, max;
max = (a > b) ? a : b; // Результат: max = 20 ( true : false )
}
```    

* Оператор switch Ще однієї альтернативою керуючої конструкції if-else може служити оператор розгалуження switch.
Синтаксис оператора switch:
```c++
switch(вираз)
{
    case Константа1 : група операторів; break ;
    case Константа2 : група операторів;  break ;
    default Константа3 : група операторів; 
}
```
```c++
switch (вираз) {
    case значення1:
        // Блок коду, який виконується, якщо вираз має значення1
        // Після виконання цього блоку, виконається нижній блок через відсутність break;
    case значення2:
        // Блок коду, який виконується, якщо вираз має значення2
        break;
    ...
    default:
        // Блок коду, який виконується, якщо вираз не має жодного зазначеного значення
        break;
}
```  
    
### Тема 1.4 | Цикли (for, while, do-while)
У мові програмування C++ є три основних типи циклів: цикл "for", цикл "while" і цикл "do-while". Кожен з них дозволяє виконувати блок коду повторно залежно від заданої умови. Опишу кожен з них детально:

* Цикл "for":
Цикл "for" складається з трьох частин: ініціалізація, умова і ітерація. Умова перевіряється перед кожною ітерацією. Якщо умова є істинною, виконується блок коду, після чого відбувається ітерація. Процес повторюється до тих пір, поки умова стає хибною. Ініціалізація виконується лише один раз на початку циклу.
    
```c++
for (ініціалізація; умова; ітерація) {
    // Блок коду, який виконується у кожній ітерації циклу
}
```
```c++
for (int i = 0; i <= 5; i++) {
    cout << i << " ";    // Результат: 0 1 2 3 4 5
}
```  

* Цикл "while":
Цикл "while" перевіряє умову перед кожною ітерацією. Якщо умова є істинною, виконується блок коду. Цикл продовжується, доки умова залишається істинною.

```c++
while (умова) {
    // Блок коду, який виконується, поки умова є істинною
}
```
                 
```c++
int i = 0;

while (i <= 5) {
    cout << i << " ";
    i++;    // Результат: 0 1 2 3 4 5
}
```  

* Цикл "do-while":
Цикл "do-while" спочатку виконує блок коду, а потім перевіряє умову. Якщо умова є істинною, цикл повторюється. Відмінністю цього циклу від "while" є те, що блок коду виконується принаймні один раз, навіть якщо умова вже хибна.
    
```с++
do {
    // Блок коду, який виконується, поки умова є істинною
} while (умова);
```
                 
```c++
int i = 0;

do {
    cout << i << " ";
    i++;
} while (i <= 5);  // Результат: 0 1 2 3 4 5
```  
    
### Тема 1.5 | Функції та повернення значень
У мові програмування C++ функції є основними засобами організації програм та виконання повторюваних завдань. Функції дозволяють групувати певні дії або операції разом та використовувати їх у різних частинах програми. Опишу структуру функції та повернення значень в C++:   
```c++
тип_повернення назва_функції(параметри) {
    // (Тіло) Блок коду, який виконується при виклику функції
    // Операції та дії, які мають бути виконані
    return значення; // Опціональне повернення значення
}
```           
* тип_повернення - це тип даних, який функція повертає після свого виконання. Якщо функція не повертає значення, то використовується тип void. 
* назва_функції - це унікальне ім'я, яке ідентифікує функцію. 
* параметри - це значення, які можуть бути передані у функцію для виконання певних операцій. Параметри є необов'язковими і можуть бути відсутніми. 
* return значення - це опціональна команда для повернення значення з функції. Вона виконується, якщо функція повертає значення.        
                
Функції в C++ можуть повертати значення за допомогою оператора return. Значення, що повертається, повинно бути того ж типу, що й зазначений у типі повернення функції. Якщо функція виконується без повернення значення (тип повернення - void), оператор return може бути пропущений або використаний без значення.
```c++
int Add(int a, int b) {
    int sum = a + b;
    return sum;  // Результат: це сума a і b
}
```         
Приклад використання нашої функції:
```c++
int result = Add(5, 5) // Результат: result = 10
```                
                
Inline-функції - це функції, які можуть бути вбудовані безпосередньо в місце їх виклику. Коли функція оголошується як inline, компілятор може вирішити скопіювати тіло функції в місце виклику, замість фактичного виклику функції. Це може привести до покращення швидкодії програми шляхом уникнення накладних витрат на виклик функції.    
```c++          
inline тип_повернення назва_функції(параметри) {
    // Тіло функції
}        
```    
                
 <details>

<summary>Ремарка як це виглядає зі строни виконання</summary>
Якщо описати нашу функцію так:

```c++
inline int Add(int a, int b)
{
    int result = a + b;
    return result;
}
```
то замість
```c++
cout << Add(2, 2);
```
ми отримаємо розворот функції в набір операторів:

```c++
int result = a + b;
cout << result;
```

</details>

Рекурсія - це процес, коли функція викликає саму себе. Рекурсивні функції розбивають велику задачу на менші частини того ж типу. Кожне викликання функції робить свій внесок у вирішення задачі, а рекурсивні виклики продовжуються досягнення базового випадку, коли рекурсія припиняється. Приклад рекурсивної функції для обчислення факторіала:
```c++
int факторіал(int n) {
    if (n == 0) {
        return 1; // Базовий випадок: факторіал 0 = 1
    } else {
        return n * факторіал(n - 1); // Рекурсивний виклик
    }
}
```
У цьому прикладі функція факторіал використовує рекурсію для обчислення факторіала числа n. Кожен рекурсивний виклик зменшує значення n на 1, аж досягне базового випадку, коли n стає рівним 0. Рекурсія вимагає добре визначеного базового випадку, щоб уникнути безкінечного виконання.

### Тема 2.1 |Огляд синтаксису C++
<details>

<summary> Точка входу в програму: </summary>
Функція main є точкою входу в програму. Вона має повернути ціле значення (зазвичай 0) і може приймати аргументи командного рядка.

```c++
int main() {
    // Тіло функції main
    return 0;
}
```
    
</details>

<details>

<summary> Оголошення змінних: </summary>
тип_даної назва_змінної;

```c++
int value;
```
    
</details>
    
<details>

<summary> Оператори присвоєння: </summary>
змінна = вираз;
    
```c++
int value = 10;
```
    
</details>
    
    
    

    
 
    
    
    
